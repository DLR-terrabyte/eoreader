<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1"/>
<meta name="generator" content="pdoc 0.9.2"/>
<title>eoreader.products.optical.optical_product API documentation</title>
<meta name="description" content="Super class for optical products"/>
<link rel="preload stylesheet" as="style"
href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css"
integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style"
href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css"
integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style"
href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/darcula.min.css"
crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100%;padding:3em 4em;border-left:1px solid #ddd;overflow-x:hidden}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}table{display:block;overflow-x:auto;word-break:keep-all;border-collapse:separate;border-spacing:0}th{background-color:#c4d5e780;padding:5px;border-bottom:0.1px solid gray;border-right:0.1px solid gray;border-top:0.1px solid gray}td,th{margin:0}td{white-space:nowrap;border-bottom:0.1px solid gray;border-right:0.1px solid gray}td:empty{background-color:#ececec}th:nth-child(1){border-left:0.1px solid gray}td:nth-child(1){border-left:0.1px solid gray;border-right:0.1px solid gray}th:nth-child(1),td:nth-child(1){background-color:#c4d5e7;position:-webkit-sticky;position:sticky;left:0}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML"
integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"
integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>eoreader.products.optical.optical_product</code></h1>
</header>
<section id="section-intro">
<p>Super class for optical products</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34; Super class for optical products &#34;&#34;&#34;

import logging
import os
from abc import abstractmethod
from typing import Callable, Union
import numpy as np
import geopandas as gpd
import rasterio
from rasterio import crs
from rasterio.enums import Resampling
from sertit import rasters, strings, misc
from sertit.snap import MAX_CORES

from eoreader.bands.alias import is_dem, is_clouds, is_index, is_optical_band, is_sar_band
from eoreader.exceptions import InvalidIndexError, InvalidBandError
from eoreader.bands.bands import OpticalBands, OpticalBandNames as obn, BandNames
from eoreader.bands import index
from eoreader.products.product import Product, SensorType
from eoreader.utils import EOREADER_NAME

LOGGER = logging.getLogger(EOREADER_NAME)


class OpticalProduct(Product):
    &#34;&#34;&#34; Super class for optical products &#34;&#34;&#34;

    def _post_init(self) -&gt; None:
        &#34;&#34;&#34;
        Function used to post_init the products
        (setting sensor type, band names and so on)
        &#34;&#34;&#34;
        self.band_names = OpticalBands()
        self._set_product_type()
        self.sensor_type = SensorType.OPTICAL

    def get_default_band(self) -&gt; BandNames:
        &#34;&#34;&#34;
        Get default band: `GREEN` for optical data as every optical satellite has a GREEN band.

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.get_default_band()
        &lt;OpticalBandNames.GREEN: &#39;GREEN&#39;&gt;
        ```

        Returns:
            str: Default band
        &#34;&#34;&#34;
        return obn.GREEN

    def get_default_band_path(self) -&gt; str:
        &#34;&#34;&#34;
        Get default band (`GREEN` for optical data) path.

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.get_default_band_path()
        &#39;zip+file://S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip!/S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE/GRANULE/L1C_T30TTK_A027018_20200824T111345/IMG_DATA/T30TTK_20200824T110631_B03.jp2&#39;
        ```

        Returns:
            str: Default band path
        &#34;&#34;&#34;
        default_band = self.get_default_band()
        return self.get_band_paths([default_band])[default_band]

    def crs(self) -&gt; rasterio.crs.CRS:
        &#34;&#34;&#34;
        Get UTM projection of the tile

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.utm_crs()
        CRS.from_epsg(32630)
        ```

        Returns:
            rasterio.crs.CRS: CRS object
        &#34;&#34;&#34;
        band_path = self.get_default_band_path()
        with rasterio.open(band_path) as dst:
            utm = dst.crs

        return utm

    def extent(self) -&gt; gpd.GeoDataFrame:
        &#34;&#34;&#34;
        Get UTM extent of the tile

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.utm_extent()
                                                    geometry
        0  POLYGON ((309780.000 4390200.000, 309780.000 4...
        ```

        Returns:
            gpd.GeoDataFrame: Footprint in UTM
        &#34;&#34;&#34;
        # Get extent
        return rasters.get_extent(self.get_default_band_path())

    def get_existing_bands(self) -&gt; list:
        &#34;&#34;&#34;
        Return the existing band paths.

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.get_existing_bands()
        [&lt;OpticalBandNames.CA: &#39;COASTAL_AEROSOL&#39;&gt;,
        &lt;OpticalBandNames.BLUE: &#39;BLUE&#39;&gt;,
        &lt;OpticalBandNames.GREEN: &#39;GREEN&#39;&gt;,
        &lt;OpticalBandNames.RED: &#39;RED&#39;&gt;,
        &lt;OpticalBandNames.VRE_1: &#39;VEGETATION_RED_EDGE_1&#39;&gt;,
        &lt;OpticalBandNames.VRE_2: &#39;VEGETATION_RED_EDGE_2&#39;&gt;,
        &lt;OpticalBandNames.VRE_3: &#39;VEGETATION_RED_EDGE_3&#39;&gt;,
        &lt;OpticalBandNames.NIR: &#39;NIR&#39;&gt;,
        &lt;OpticalBandNames.NNIR: &#39;NARROW_NIR&#39;&gt;,
        &lt;OpticalBandNames.WV: &#39;WATER_VAPOUR&#39;&gt;,
        &lt;OpticalBandNames.CIRRUS: &#39;CIRRUS&#39;&gt;,
        &lt;OpticalBandNames.SWIR_1: &#39;SWIR_1&#39;&gt;,
        &lt;OpticalBandNames.SWIR_2: &#39;SWIR_2&#39;&gt;]
        ```

        Returns:
            list: List of existing bands in the products
        &#34;&#34;&#34;
        return [name for name, nb in self.band_names.items() if nb]

    def get_existing_band_paths(self) -&gt; dict:
        &#34;&#34;&#34;
        Return the existing band paths.

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.get_existing_band_paths()
        {
            &lt;OpticalBandNames.CA: &#39;COASTAL_AEROSOL&#39;&gt;: &#39;zip+file://S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip!/S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE/GRANULE/L1C_T30TTK_A027018_20200824T111345/IMG_DATA/T30TTK_20200824T110631_B01.jp2&#39;,
            ...,
            &lt;OpticalBandNames.SWIR_2: &#39;SWIR_2&#39;&gt;: &#39;zip+file://S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip!/S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE/GRANULE/L1C_T30TTK_A027018_20200824T111345/IMG_DATA/T30TTK_20200824T110631_B12.jp2&#39;
        }
        ```

        Returns:
            dict: Dictionary containing the path of each queried band
        &#34;&#34;&#34;
        existing_bands = self.get_existing_bands()
        return self.get_band_paths(band_list=existing_bands)

    def _open_bands(self,
                    band_paths: dict,
                    resolution: float = None,
                    size: Union[list, tuple] = None) -&gt; (dict, dict):
        &#34;&#34;&#34;
        Open bands from their paths.

        Args:
            band_paths (dict): Band dict: {band_enum: band_path}
            resolution (float): Band resolution in meters
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.

        Returns:
            dict, dict: Dictionary {band_name, band_array} and the products metadata
                        (supposed to be the same for all bands)

        &#34;&#34;&#34;
        # Open bands and get array (resampled if needed)
        band_arrays = {}
        meta = {}
        for band_name, band_path in band_paths.items():
            # Read band
            band_arrays[band_name], ds_meta = self._read_band(band_path, resolution=resolution, size=size)
            band_arrays[band_name], ds_meta = self._manage_invalid_pixels(band_arrays[band_name],
                                                                          band_name, ds_meta,
                                                                          resolution=resolution,
                                                                          size=size)

            # Meta
            if not meta:
                meta = ds_meta.copy()

        return band_arrays, meta

    # pylint: disable=R0913
    # R0913: Too many arguments (6/5) (too-many-arguments)
    @abstractmethod
    def _manage_invalid_pixels(self,
                               band_arr: np.ma.masked_array,
                               band: obn,
                               meta: dict,
                               resolution: float = None,
                               size: Union[list, tuple] = None) -&gt; (np.ma.masked_array, dict):
        &#34;&#34;&#34;
        Manage invalid pixels (Nodata, saturated, defective...)

        Args:
            band_arr (np.ma.masked_array): Band array loaded
            band (obn): Band name as an OpticalBandNames
            meta (dict): Band metadata from rasterio
            resolution (float): Band resolution in meters
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.

        Returns:
            np.ma.masked_array, dict: Cleaned band array and its metadata
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)

    def _create_band_masked_array(self,
                                  band_arr: np.ma.masked_array,
                                  mask: np.ndarray,
                                  meta: dict) -&gt; (np.ma.masked_array, dict):
        &#34;&#34;&#34;
        Create the correct masked array with well positioned nodata and values properly set to nodata

        Args:
            band_arr (np.ma.masked_array): Band array
                (should already be a masked array as it comes from rasterio.read(..., masked=True)
            mask (np.ndarray): Mask array, should be the same size as band_arr (in 2D)
            meta (dict): Metadata of the band array

        Returns:
            (np.ma.masked_array, dict): Corrected band array and updated metadata
        &#34;&#34;&#34;
        # Binary mask
        if mask.dtype != np.uint8:
            mask = mask.astype(np.uint8)

        if len(mask.shape) &lt; len(band_arr.shape):
            mask = np.expand_dims(mask, axis=0)

        # Set ok pixels that have 0 value to epsilon
        eps = 0.0001  # min value to be set to 1 when saved as uint16 (*10000)
        # band_arr[band_arr.data == self.nodata] = eps  # Do not let not nodata pixels to 0
        # band_arr[mask == 1] = self.nodata  # Set no data pixels to the correct value
        # band_arr.mask = mask
        # band_arr.fill_value = self.nodata

        band_arr_mask = np.ma.masked_array(np.where(band_arr == self.nodata, eps, band_arr),
                                           mask=mask,
                                           fill_value=self.nodata,
                                           dtype=band_arr.dtype)
        meta[&#34;nodata&#34;] = self.nodata

        return band_arr_mask, meta

    def load(self,
             band_and_idx_list: Union[list, BandNames, Callable],
             resolution: float = None,
             size: Union[list, tuple] = None) -&gt; (dict, dict):
        &#34;&#34;&#34;
        Open the bands and compute the wanted index.

        The bands will be purged of nodata and invalid pixels,
        the nodata will be set to 0 and the bands will be masked arrays in float.

        Bands that come out this function at the same time are collocated and therefore have the same shapes.
        This can be broken if you load data separately. Its is best to always load DEM data with some real bands.

        If neither resolution nor size is given, bands will be loaded at the product&#39;s default resolution.

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; from eoreader.bands.alias import *
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; bands, meta = prod.load([GREEN, NDVI], resolution=20)
        &gt;&gt;&gt; bands
        {&lt;function NDVI at 0x00000227FBB929D8&gt;: masked_array(
          data=[[[-0.02004455029964447, ..., 0.11663568764925003]]],
          mask=[[[False, ..., False]]],
          fill_value=0.0,
          dtype=float32),
          &lt;OpticalBandNames.GREEN: &#39;GREEN&#39;&gt;: masked_array(
          data=[[[0.061400000005960464, ..., 0.15799999237060547]]],
          mask=[[[False, ..., False]]],
          fill_value=0.0,
          dtype=float32)}
        &gt;&gt;&gt; meta
        {
            &#39;driver&#39;: &#39;GTiff&#39;,
            &#39;dtype&#39;: &lt;class &#39;numpy.float32&#39;&gt;,
            &#39;nodata&#39;: 0,
            &#39;width&#39;: 5490,
            &#39;height&#39;: 5490,
            &#39;count&#39;: 1,
            &#39;crs&#39;: CRS.from_epsg(32630),
            &#39;transform&#39;: Affine(20.0, 0.0, 199980.0,0.0, -20.0, 4500000.0)
        }
        ```

        Args:
            band_and_idx_list (list, index): Index list
            resolution (float): Resolution of the band, in meters
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.

        Returns:
            dict, dict: Index and band dict, metadata
        &#34;&#34;&#34;
        if not resolution and not size:
            resolution = self.resolution

        if not isinstance(band_and_idx_list, list):
            band_and_idx_list = [band_and_idx_list]

        if len(band_and_idx_list) == 0:
            return {}, {}

        band_list = []
        index_list = []
        dem_list = []
        clouds_list = []

        # Check if everything is valid
        for idx_or_band in band_and_idx_list:
            if is_index(idx_or_band):
                if self._has_index(idx_or_band):
                    index_list.append(idx_or_band)
                else:
                    raise InvalidIndexError(f&#34;{idx_or_band} cannot be computed from {self.condensed_name}.&#34;)
            elif is_sar_band(idx_or_band):
                raise TypeError(f&#34;You should ask for Optical bands as {self.name} is an optical product.&#34;)
            elif is_optical_band(idx_or_band):
                if self.has_band(idx_or_band):
                    band_list.append(idx_or_band)
                else:
                    raise InvalidBandError(f&#34;{idx_or_band} cannot be retrieved from {self.condensed_name}.&#34;)
            elif is_dem(idx_or_band):
                dem_list.append(idx_or_band)
            elif is_clouds(idx_or_band):
                clouds_list.append(idx_or_band)

        # Get all bands to be open
        bands_to_load = band_list.copy()
        for idx in index_list:
            bands_to_load += index.NEEDED_BANDS[idx]

        # Load band arrays (only keep unique bands: open them only one time !)
        bands, meta = self._load_bands(list(set(bands_to_load)), resolution=resolution, size=size)

        # Compute index (they conserve the nodata)
        idx_and_bands_dict = {idx: idx(bands) for idx in index_list}

        # Add bands
        idx_and_bands_dict.update({band: bands[band] for band in band_list})

        # Add DEM
        dem_bands, dem_meta = self._load_dem(dem_list, resolution=resolution, size=size)
        idx_and_bands_dict.update(dem_bands)
        if not meta:
            meta = dem_meta

        # Add Clouds
        clouds_bands, clouds_meta = self._load_clouds(clouds_list, resolution=resolution, size=size)
        idx_and_bands_dict.update(clouds_bands)
        if not meta:
            meta = clouds_meta

        # Manage the case of arrays of different size -&gt; collocate arrays if needed
        idx_and_bands_dict = self._collocate_bands(idx_and_bands_dict, meta)

        return idx_and_bands_dict, meta

    @abstractmethod
    def get_mean_sun_angles(self) -&gt; (float, float):
        &#34;&#34;&#34;
        Get Mean Sun angles (Azimuth and Zenith angles)

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.get_mean_sun_angles()
        (149.148155074489, 32.6627897525474)
        ```

        Returns:
            (float, float): Mean Azimuth and Zenith angle
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)

    def _compute_hillshade(self,
                           dem_path: str = &#34;&#34;,
                           resolution: Union[float, tuple] = None,
                           size: Union[list, tuple] = None,
                           resampling: Resampling = Resampling.bilinear) -&gt; str:
        &#34;&#34;&#34;
        Compute Hillshade mask

        Args:
            dem_path (str): DEM path, using EUDEM/MERIT DEM if none
            resolution (Union[float, tuple]): Resolution in meters. If not specified, use the product resolution.
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.
            resampling (Resampling): Resampling method

        Returns:
            str: Hillshade mask path

        &#34;&#34;&#34;
        # Warp DEM
        warped_dem_path = self._warp_dem(dem_path, resolution, size, resampling)

        # Get Hillshade path
        hillshade_dem = os.path.join(self.output, f&#34;{self.condensed_name}_HILLSHADE.tif&#34;)
        if os.path.isfile(hillshade_dem):
            LOGGER.debug(&#34;Already existing hillshade DEM for %s. Skipping process.&#34;, self.name)
        else:
            LOGGER.debug(&#34;Computing hillshade DEM for %s&#34;, self.name)

            # Get angles
            mean_azimuth_angle, mean_zenith_angle = self.get_mean_sun_angles()
            zenith = 90.0 - mean_zenith_angle
            azimuth = mean_azimuth_angle

            # Run cmd
            cmd_hillshade = [&#34;gdaldem&#34;, &#34;--config&#34;,
                             &#34;NUM_THREADS&#34;, MAX_CORES,
                             &#34;hillshade&#34;, strings.to_cmd_string(warped_dem_path),
                             &#34;-compute_edges&#34;,
                             &#34;-z&#34;, &#34;1&#34;,
                             &#34;-az&#34;, azimuth,
                             &#34;-alt&#34;, zenith,
                             &#34;-of&#34;, &#34;GTiff&#34;,
                             strings.to_cmd_string(hillshade_dem)]
            # Run command
            misc.run_cli(cmd_hillshade)

        return hillshade_dem

    def _load_clouds(self,
                  band_list: Union[list, BandNames],
                  resolution: float = None,
                  size: Union[list, tuple] = None) -&gt; (dict, dict):
        &#34;&#34;&#34;
        Load cloud files as numpy arrays with the same resolution (and same metadata).

        Args:
            band_list (Union[list, BandNames]): List of the wanted bands
            resolution (int): Band resolution in meters
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.
        Returns:
            dict, dict: Dictionary {band_name, band_array} and the products metadata
                        (supposed to be the same for all bands)
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="eoreader.products.optical.optical_product.OpticalProduct"><code class="flex name class">
<span>class <span class="ident">OpticalProduct</span></span>
<span>(</span><span>product_path, archive_path=None, output_path=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Super class for optical products</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OpticalProduct(Product):
    &#34;&#34;&#34; Super class for optical products &#34;&#34;&#34;

    def _post_init(self) -&gt; None:
        &#34;&#34;&#34;
        Function used to post_init the products
        (setting sensor type, band names and so on)
        &#34;&#34;&#34;
        self.band_names = OpticalBands()
        self._set_product_type()
        self.sensor_type = SensorType.OPTICAL

    def get_default_band(self) -&gt; BandNames:
        &#34;&#34;&#34;
        Get default band: `GREEN` for optical data as every optical satellite has a GREEN band.

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.get_default_band()
        &lt;OpticalBandNames.GREEN: &#39;GREEN&#39;&gt;
        ```

        Returns:
            str: Default band
        &#34;&#34;&#34;
        return obn.GREEN

    def get_default_band_path(self) -&gt; str:
        &#34;&#34;&#34;
        Get default band (`GREEN` for optical data) path.

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.get_default_band_path()
        &#39;zip+file://S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip!/S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE/GRANULE/L1C_T30TTK_A027018_20200824T111345/IMG_DATA/T30TTK_20200824T110631_B03.jp2&#39;
        ```

        Returns:
            str: Default band path
        &#34;&#34;&#34;
        default_band = self.get_default_band()
        return self.get_band_paths([default_band])[default_band]

    def crs(self) -&gt; rasterio.crs.CRS:
        &#34;&#34;&#34;
        Get UTM projection of the tile

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.utm_crs()
        CRS.from_epsg(32630)
        ```

        Returns:
            rasterio.crs.CRS: CRS object
        &#34;&#34;&#34;
        band_path = self.get_default_band_path()
        with rasterio.open(band_path) as dst:
            utm = dst.crs

        return utm

    def extent(self) -&gt; gpd.GeoDataFrame:
        &#34;&#34;&#34;
        Get UTM extent of the tile

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.utm_extent()
                                                    geometry
        0  POLYGON ((309780.000 4390200.000, 309780.000 4...
        ```

        Returns:
            gpd.GeoDataFrame: Footprint in UTM
        &#34;&#34;&#34;
        # Get extent
        return rasters.get_extent(self.get_default_band_path())

    def get_existing_bands(self) -&gt; list:
        &#34;&#34;&#34;
        Return the existing band paths.

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.get_existing_bands()
        [&lt;OpticalBandNames.CA: &#39;COASTAL_AEROSOL&#39;&gt;,
        &lt;OpticalBandNames.BLUE: &#39;BLUE&#39;&gt;,
        &lt;OpticalBandNames.GREEN: &#39;GREEN&#39;&gt;,
        &lt;OpticalBandNames.RED: &#39;RED&#39;&gt;,
        &lt;OpticalBandNames.VRE_1: &#39;VEGETATION_RED_EDGE_1&#39;&gt;,
        &lt;OpticalBandNames.VRE_2: &#39;VEGETATION_RED_EDGE_2&#39;&gt;,
        &lt;OpticalBandNames.VRE_3: &#39;VEGETATION_RED_EDGE_3&#39;&gt;,
        &lt;OpticalBandNames.NIR: &#39;NIR&#39;&gt;,
        &lt;OpticalBandNames.NNIR: &#39;NARROW_NIR&#39;&gt;,
        &lt;OpticalBandNames.WV: &#39;WATER_VAPOUR&#39;&gt;,
        &lt;OpticalBandNames.CIRRUS: &#39;CIRRUS&#39;&gt;,
        &lt;OpticalBandNames.SWIR_1: &#39;SWIR_1&#39;&gt;,
        &lt;OpticalBandNames.SWIR_2: &#39;SWIR_2&#39;&gt;]
        ```

        Returns:
            list: List of existing bands in the products
        &#34;&#34;&#34;
        return [name for name, nb in self.band_names.items() if nb]

    def get_existing_band_paths(self) -&gt; dict:
        &#34;&#34;&#34;
        Return the existing band paths.

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.get_existing_band_paths()
        {
            &lt;OpticalBandNames.CA: &#39;COASTAL_AEROSOL&#39;&gt;: &#39;zip+file://S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip!/S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE/GRANULE/L1C_T30TTK_A027018_20200824T111345/IMG_DATA/T30TTK_20200824T110631_B01.jp2&#39;,
            ...,
            &lt;OpticalBandNames.SWIR_2: &#39;SWIR_2&#39;&gt;: &#39;zip+file://S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip!/S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE/GRANULE/L1C_T30TTK_A027018_20200824T111345/IMG_DATA/T30TTK_20200824T110631_B12.jp2&#39;
        }
        ```

        Returns:
            dict: Dictionary containing the path of each queried band
        &#34;&#34;&#34;
        existing_bands = self.get_existing_bands()
        return self.get_band_paths(band_list=existing_bands)

    def _open_bands(self,
                    band_paths: dict,
                    resolution: float = None,
                    size: Union[list, tuple] = None) -&gt; (dict, dict):
        &#34;&#34;&#34;
        Open bands from their paths.

        Args:
            band_paths (dict): Band dict: {band_enum: band_path}
            resolution (float): Band resolution in meters
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.

        Returns:
            dict, dict: Dictionary {band_name, band_array} and the products metadata
                        (supposed to be the same for all bands)

        &#34;&#34;&#34;
        # Open bands and get array (resampled if needed)
        band_arrays = {}
        meta = {}
        for band_name, band_path in band_paths.items():
            # Read band
            band_arrays[band_name], ds_meta = self._read_band(band_path, resolution=resolution, size=size)
            band_arrays[band_name], ds_meta = self._manage_invalid_pixels(band_arrays[band_name],
                                                                          band_name, ds_meta,
                                                                          resolution=resolution,
                                                                          size=size)

            # Meta
            if not meta:
                meta = ds_meta.copy()

        return band_arrays, meta

    # pylint: disable=R0913
    # R0913: Too many arguments (6/5) (too-many-arguments)
    @abstractmethod
    def _manage_invalid_pixels(self,
                               band_arr: np.ma.masked_array,
                               band: obn,
                               meta: dict,
                               resolution: float = None,
                               size: Union[list, tuple] = None) -&gt; (np.ma.masked_array, dict):
        &#34;&#34;&#34;
        Manage invalid pixels (Nodata, saturated, defective...)

        Args:
            band_arr (np.ma.masked_array): Band array loaded
            band (obn): Band name as an OpticalBandNames
            meta (dict): Band metadata from rasterio
            resolution (float): Band resolution in meters
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.

        Returns:
            np.ma.masked_array, dict: Cleaned band array and its metadata
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)

    def _create_band_masked_array(self,
                                  band_arr: np.ma.masked_array,
                                  mask: np.ndarray,
                                  meta: dict) -&gt; (np.ma.masked_array, dict):
        &#34;&#34;&#34;
        Create the correct masked array with well positioned nodata and values properly set to nodata

        Args:
            band_arr (np.ma.masked_array): Band array
                (should already be a masked array as it comes from rasterio.read(..., masked=True)
            mask (np.ndarray): Mask array, should be the same size as band_arr (in 2D)
            meta (dict): Metadata of the band array

        Returns:
            (np.ma.masked_array, dict): Corrected band array and updated metadata
        &#34;&#34;&#34;
        # Binary mask
        if mask.dtype != np.uint8:
            mask = mask.astype(np.uint8)

        if len(mask.shape) &lt; len(band_arr.shape):
            mask = np.expand_dims(mask, axis=0)

        # Set ok pixels that have 0 value to epsilon
        eps = 0.0001  # min value to be set to 1 when saved as uint16 (*10000)
        # band_arr[band_arr.data == self.nodata] = eps  # Do not let not nodata pixels to 0
        # band_arr[mask == 1] = self.nodata  # Set no data pixels to the correct value
        # band_arr.mask = mask
        # band_arr.fill_value = self.nodata

        band_arr_mask = np.ma.masked_array(np.where(band_arr == self.nodata, eps, band_arr),
                                           mask=mask,
                                           fill_value=self.nodata,
                                           dtype=band_arr.dtype)
        meta[&#34;nodata&#34;] = self.nodata

        return band_arr_mask, meta

    def load(self,
             band_and_idx_list: Union[list, BandNames, Callable],
             resolution: float = None,
             size: Union[list, tuple] = None) -&gt; (dict, dict):
        &#34;&#34;&#34;
        Open the bands and compute the wanted index.

        The bands will be purged of nodata and invalid pixels,
        the nodata will be set to 0 and the bands will be masked arrays in float.

        Bands that come out this function at the same time are collocated and therefore have the same shapes.
        This can be broken if you load data separately. Its is best to always load DEM data with some real bands.

        If neither resolution nor size is given, bands will be loaded at the product&#39;s default resolution.

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; from eoreader.bands.alias import *
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; bands, meta = prod.load([GREEN, NDVI], resolution=20)
        &gt;&gt;&gt; bands
        {&lt;function NDVI at 0x00000227FBB929D8&gt;: masked_array(
          data=[[[-0.02004455029964447, ..., 0.11663568764925003]]],
          mask=[[[False, ..., False]]],
          fill_value=0.0,
          dtype=float32),
          &lt;OpticalBandNames.GREEN: &#39;GREEN&#39;&gt;: masked_array(
          data=[[[0.061400000005960464, ..., 0.15799999237060547]]],
          mask=[[[False, ..., False]]],
          fill_value=0.0,
          dtype=float32)}
        &gt;&gt;&gt; meta
        {
            &#39;driver&#39;: &#39;GTiff&#39;,
            &#39;dtype&#39;: &lt;class &#39;numpy.float32&#39;&gt;,
            &#39;nodata&#39;: 0,
            &#39;width&#39;: 5490,
            &#39;height&#39;: 5490,
            &#39;count&#39;: 1,
            &#39;crs&#39;: CRS.from_epsg(32630),
            &#39;transform&#39;: Affine(20.0, 0.0, 199980.0,0.0, -20.0, 4500000.0)
        }
        ```

        Args:
            band_and_idx_list (list, index): Index list
            resolution (float): Resolution of the band, in meters
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.

        Returns:
            dict, dict: Index and band dict, metadata
        &#34;&#34;&#34;
        if not resolution and not size:
            resolution = self.resolution

        if not isinstance(band_and_idx_list, list):
            band_and_idx_list = [band_and_idx_list]

        if len(band_and_idx_list) == 0:
            return {}, {}

        band_list = []
        index_list = []
        dem_list = []
        clouds_list = []

        # Check if everything is valid
        for idx_or_band in band_and_idx_list:
            if is_index(idx_or_band):
                if self._has_index(idx_or_band):
                    index_list.append(idx_or_band)
                else:
                    raise InvalidIndexError(f&#34;{idx_or_band} cannot be computed from {self.condensed_name}.&#34;)
            elif is_sar_band(idx_or_band):
                raise TypeError(f&#34;You should ask for Optical bands as {self.name} is an optical product.&#34;)
            elif is_optical_band(idx_or_band):
                if self.has_band(idx_or_band):
                    band_list.append(idx_or_band)
                else:
                    raise InvalidBandError(f&#34;{idx_or_band} cannot be retrieved from {self.condensed_name}.&#34;)
            elif is_dem(idx_or_band):
                dem_list.append(idx_or_band)
            elif is_clouds(idx_or_band):
                clouds_list.append(idx_or_band)

        # Get all bands to be open
        bands_to_load = band_list.copy()
        for idx in index_list:
            bands_to_load += index.NEEDED_BANDS[idx]

        # Load band arrays (only keep unique bands: open them only one time !)
        bands, meta = self._load_bands(list(set(bands_to_load)), resolution=resolution, size=size)

        # Compute index (they conserve the nodata)
        idx_and_bands_dict = {idx: idx(bands) for idx in index_list}

        # Add bands
        idx_and_bands_dict.update({band: bands[band] for band in band_list})

        # Add DEM
        dem_bands, dem_meta = self._load_dem(dem_list, resolution=resolution, size=size)
        idx_and_bands_dict.update(dem_bands)
        if not meta:
            meta = dem_meta

        # Add Clouds
        clouds_bands, clouds_meta = self._load_clouds(clouds_list, resolution=resolution, size=size)
        idx_and_bands_dict.update(clouds_bands)
        if not meta:
            meta = clouds_meta

        # Manage the case of arrays of different size -&gt; collocate arrays if needed
        idx_and_bands_dict = self._collocate_bands(idx_and_bands_dict, meta)

        return idx_and_bands_dict, meta

    @abstractmethod
    def get_mean_sun_angles(self) -&gt; (float, float):
        &#34;&#34;&#34;
        Get Mean Sun angles (Azimuth and Zenith angles)

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.get_mean_sun_angles()
        (149.148155074489, 32.6627897525474)
        ```

        Returns:
            (float, float): Mean Azimuth and Zenith angle
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)

    def _compute_hillshade(self,
                           dem_path: str = &#34;&#34;,
                           resolution: Union[float, tuple] = None,
                           size: Union[list, tuple] = None,
                           resampling: Resampling = Resampling.bilinear) -&gt; str:
        &#34;&#34;&#34;
        Compute Hillshade mask

        Args:
            dem_path (str): DEM path, using EUDEM/MERIT DEM if none
            resolution (Union[float, tuple]): Resolution in meters. If not specified, use the product resolution.
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.
            resampling (Resampling): Resampling method

        Returns:
            str: Hillshade mask path

        &#34;&#34;&#34;
        # Warp DEM
        warped_dem_path = self._warp_dem(dem_path, resolution, size, resampling)

        # Get Hillshade path
        hillshade_dem = os.path.join(self.output, f&#34;{self.condensed_name}_HILLSHADE.tif&#34;)
        if os.path.isfile(hillshade_dem):
            LOGGER.debug(&#34;Already existing hillshade DEM for %s. Skipping process.&#34;, self.name)
        else:
            LOGGER.debug(&#34;Computing hillshade DEM for %s&#34;, self.name)

            # Get angles
            mean_azimuth_angle, mean_zenith_angle = self.get_mean_sun_angles()
            zenith = 90.0 - mean_zenith_angle
            azimuth = mean_azimuth_angle

            # Run cmd
            cmd_hillshade = [&#34;gdaldem&#34;, &#34;--config&#34;,
                             &#34;NUM_THREADS&#34;, MAX_CORES,
                             &#34;hillshade&#34;, strings.to_cmd_string(warped_dem_path),
                             &#34;-compute_edges&#34;,
                             &#34;-z&#34;, &#34;1&#34;,
                             &#34;-az&#34;, azimuth,
                             &#34;-alt&#34;, zenith,
                             &#34;-of&#34;, &#34;GTiff&#34;,
                             strings.to_cmd_string(hillshade_dem)]
            # Run command
            misc.run_cli(cmd_hillshade)

        return hillshade_dem

    def _load_clouds(self,
                  band_list: Union[list, BandNames],
                  resolution: float = None,
                  size: Union[list, tuple] = None) -&gt; (dict, dict):
        &#34;&#34;&#34;
        Load cloud files as numpy arrays with the same resolution (and same metadata).

        Args:
            band_list (Union[list, BandNames]): List of the wanted bands
            resolution (int): Band resolution in meters
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.
        Returns:
            dict, dict: Dictionary {band_name, band_array} and the products metadata
                        (supposed to be the same for all bands)
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="eoreader.products.product.Product" href="../product.html#eoreader.products.product.Product">Product</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="eoreader.products.optical.landsat_product.LandsatProduct" href="landsat_product.html#eoreader.products.optical.landsat_product.LandsatProduct">LandsatProduct</a></li>
<li><a title="eoreader.products.optical.s2_product.S2Product" href="s2_product.html#eoreader.products.optical.s2_product.S2Product">S2Product</a></li>
<li><a title="eoreader.products.optical.s2_theia_product.S2TheiaProduct" href="s2_theia_product.html#eoreader.products.optical.s2_theia_product.S2TheiaProduct">S2TheiaProduct</a></li>
<li><a title="eoreader.products.optical.s3_product.S3Product" href="s3_product.html#eoreader.products.optical.s3_product.S3Product">S3Product</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="eoreader.products.optical.optical_product.OpticalProduct.output"><code class="name">var <span class="ident">output</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.product.Product" href="../product.html#eoreader.products.product.Product">Product</a></code>.<code><a title="eoreader.products.product.Product.output" href="../product.html#eoreader.products.product.Product.output">output</a></code>
</p>
<div class="desc inherited"><p>Output directory of the product, to write orthorectified data for example.</p></div>
</dd>
<dt id="eoreader.products.optical.optical_product.OpticalProduct.name"><code class="name">var <span class="ident">name</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.product.Product" href="../product.html#eoreader.products.product.Product">Product</a></code>.<code><a title="eoreader.products.product.Product.name" href="../product.html#eoreader.products.product.Product.name">name</a></code>
</p>
<div class="desc inherited"><p>Product name (its filename without any extension).</p></div>
</dd>
<dt id="eoreader.products.optical.optical_product.OpticalProduct.split_name"><code class="name">var <span class="ident">split_name</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.product.Product" href="../product.html#eoreader.products.product.Product">Product</a></code>.<code><a title="eoreader.products.product.Product.split_name" href="../product.html#eoreader.products.product.Product.split_name">split_name</a></code>
</p>
<div class="desc inherited"><p>Split name, to retrieve every information from its filename (dates, tile, product type&hellip;).</p></div>
</dd>
<dt id="eoreader.products.optical.optical_product.OpticalProduct.archive_path"><code class="name">var <span class="ident">archive_path</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.product.Product" href="../product.html#eoreader.products.product.Product">Product</a></code>.<code><a title="eoreader.products.product.Product.archive_path" href="../product.html#eoreader.products.product.Product.archive_path">archive_path</a></code>
</p>
<div class="desc inherited"><p>Archive path, same as the product path if not specified.
Useful when you want to know where both the extracted and archived version of your product …</p></div>
</dd>
<dt id="eoreader.products.optical.optical_product.OpticalProduct.path"><code class="name">var <span class="ident">path</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.product.Product" href="../product.html#eoreader.products.product.Product">Product</a></code>.<code><a title="eoreader.products.product.Product.path" href="../product.html#eoreader.products.product.Product.path">path</a></code>
</p>
<div class="desc inherited"><p>Usable path to the product, either extracted or archived path, according to the satellite.</p></div>
</dd>
<dt id="eoreader.products.optical.optical_product.OpticalProduct.is_archived"><code class="name">var <span class="ident">is_archived</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.product.Product" href="../product.html#eoreader.products.product.Product">Product</a></code>.<code><a title="eoreader.products.product.Product.is_archived" href="../product.html#eoreader.products.product.Product.is_archived">is_archived</a></code>
</p>
<div class="desc inherited"><p>Is the archived product is processed
(a products is considered as archived if its products path is a directory).</p></div>
</dd>
<dt id="eoreader.products.optical.optical_product.OpticalProduct.needs_extraction"><code class="name">var <span class="ident">needs_extraction</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.product.Product" href="../product.html#eoreader.products.product.Product">Product</a></code>.<code><a title="eoreader.products.product.Product.needs_extraction" href="../product.html#eoreader.products.product.Product.needs_extraction">needs_extraction</a></code>
</p>
<div class="desc inherited"><p>Does this products needs to be extracted to be processed ? (<code>True</code> by default).</p></div>
</dd>
<dt id="eoreader.products.optical.optical_product.OpticalProduct.date"><code class="name">var <span class="ident">date</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.product.Product" href="../product.html#eoreader.products.product.Product">Product</a></code>.<code><a title="eoreader.products.product.Product.date" href="../product.html#eoreader.products.product.Product.date">date</a></code>
</p>
<div class="desc inherited"><p>Acquisition date.</p></div>
</dd>
<dt id="eoreader.products.optical.optical_product.OpticalProduct.datetime"><code class="name">var <span class="ident">datetime</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.product.Product" href="../product.html#eoreader.products.product.Product">Product</a></code>.<code><a title="eoreader.products.product.Product.datetime" href="../product.html#eoreader.products.product.Product.datetime">datetime</a></code>
</p>
<div class="desc inherited"><p>Acquisition datetime.</p></div>
</dd>
<dt id="eoreader.products.optical.optical_product.OpticalProduct.tile_name"><code class="name">var <span class="ident">tile_name</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.product.Product" href="../product.html#eoreader.products.product.Product">Product</a></code>.<code><a title="eoreader.products.product.Product.tile_name" href="../product.html#eoreader.products.product.Product.tile_name">tile_name</a></code>
</p>
<div class="desc inherited"><p>Tile if possible (for data that can be piled, for example S2 and Landsats).</p></div>
</dd>
<dt id="eoreader.products.optical.optical_product.OpticalProduct.sensor_type"><code class="name">var <span class="ident">sensor_type</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.product.Product" href="../product.html#eoreader.products.product.Product">Product</a></code>.<code><a title="eoreader.products.product.Product.sensor_type" href="../product.html#eoreader.products.product.Product.sensor_type">sensor_type</a></code>
</p>
<div class="desc inherited"><p>Sensor type, SAR or optical.</p></div>
</dd>
<dt id="eoreader.products.optical.optical_product.OpticalProduct.product_type"><code class="name">var <span class="ident">product_type</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.product.Product" href="../product.html#eoreader.products.product.Product">Product</a></code>.<code><a title="eoreader.products.product.Product.product_type" href="../product.html#eoreader.products.product.Product.product_type">product_type</a></code>
</p>
<div class="desc inherited"><p>Product type, satellite-related field, such as L1C or L2A for Sentinel-2 data.</p></div>
</dd>
<dt id="eoreader.products.optical.optical_product.OpticalProduct.band_names"><code class="name">var <span class="ident">band_names</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.product.Product" href="../product.html#eoreader.products.product.Product">Product</a></code>.<code><a title="eoreader.products.product.Product.band_names" href="../product.html#eoreader.products.product.Product.band_names">band_names</a></code>
</p>
<div class="desc inherited"><p>Band mapping between band wrapping names such as <code>GREEN</code> and band real number such as <code>03</code> for Sentinel-2.</p></div>
</dd>
<dt id="eoreader.products.optical.optical_product.OpticalProduct.is_reference"><code class="name">var <span class="ident">is_reference</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.product.Product" href="../product.html#eoreader.products.product.Product">Product</a></code>.<code><a title="eoreader.products.product.Product.is_reference" href="../product.html#eoreader.products.product.Product.is_reference">is_reference</a></code>
</p>
<div class="desc inherited"><p>If the product is a reference, used for algorithms that need pre and post data, such as fire detection.</p></div>
</dd>
<dt id="eoreader.products.optical.optical_product.OpticalProduct.corresponding_ref"><code class="name">var <span class="ident">corresponding_ref</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.product.Product" href="../product.html#eoreader.products.product.Product">Product</a></code>.<code><a title="eoreader.products.product.Product.corresponding_ref" href="../product.html#eoreader.products.product.Product.corresponding_ref">corresponding_ref</a></code>
</p>
<div class="desc inherited"><p>The corresponding reference products to the current one
(if the product is not a reference but has a reference data corresponding to it).
A list …</p></div>
</dd>
<dt id="eoreader.products.optical.optical_product.OpticalProduct.nodata"><code class="name">var <span class="ident">nodata</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.product.Product" href="../product.html#eoreader.products.product.Product">Product</a></code>.<code><a title="eoreader.products.product.Product.nodata" href="../product.html#eoreader.products.product.Product.nodata">nodata</a></code>
</p>
<div class="desc inherited"><p>Product nodata, set to 0 by default. Please do not touch this or all index will fail.</p></div>
</dd>
<dt id="eoreader.products.optical.optical_product.OpticalProduct.platform"><code class="name">var <span class="ident">platform</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.product.Product" href="../product.html#eoreader.products.product.Product">Product</a></code>.<code><a title="eoreader.products.product.Product.platform" href="../product.html#eoreader.products.product.Product.platform">platform</a></code>
</p>
<div class="desc inherited"><p>Product platform, such as Sentinel-2</p></div>
</dd>
<dt id="eoreader.products.optical.optical_product.OpticalProduct.resolution"><code class="name">var <span class="ident">resolution</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.product.Product" href="../product.html#eoreader.products.product.Product">Product</a></code>.<code><a title="eoreader.products.product.Product.resolution" href="../product.html#eoreader.products.product.Product.resolution">resolution</a></code>
</p>
<div class="desc inherited"><p>Default resolution in meters of the current product.
For SAR product, we use Ground Range resolution as we will automatically orthorectify the tiles.</p></div>
</dd>
<dt id="eoreader.products.optical.optical_product.OpticalProduct.condensed_name"><code class="name">var <span class="ident">condensed_name</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.product.Product" href="../product.html#eoreader.products.product.Product">Product</a></code>.<code><a title="eoreader.products.product.Product.condensed_name" href="../product.html#eoreader.products.product.Product.condensed_name">condensed_name</a></code>
</p>
<div class="desc inherited"><p>Condensed name, the filename with only useful data to keep the name unique
(ie. <code>20191215T110441_S2_30TXP_L2A_122756</code>).
Used to shorten names and …</p></div>
</dd>
<dt id="eoreader.products.optical.optical_product.OpticalProduct.sat_id"><code class="name">var <span class="ident">sat_id</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.product.Product" href="../product.html#eoreader.products.product.Product">Product</a></code>.<code><a title="eoreader.products.product.Product.sat_id" href="../product.html#eoreader.products.product.Product.sat_id">sat_id</a></code>
</p>
<div class="desc inherited"><p>Satellite ID, i.e. <code>S2</code> for Sentinel-2</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="eoreader.products.optical.optical_product.OpticalProduct.get_default_band"><code class="name flex">
<p>def <span class="ident">get_default_band</span>(</p><p>self)</p>
</code></dt>
<dd>
<div class="desc"><p>Get default band: <code>GREEN</code> for optical data as every optical satellite has a GREEN band.</p>
<pre><code class="language-python">&gt;&gt;&gt; from eoreader.reader import Reader
&gt;&gt;&gt; path = r&quot;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&quot;
&gt;&gt;&gt; prod = Reader().open(path)
&gt;&gt;&gt; prod.get_default_band()
&lt;OpticalBandNames.GREEN: 'GREEN'&gt;
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Default band</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_default_band(self) -&gt; BandNames:
    &#34;&#34;&#34;
    Get default band: `GREEN` for optical data as every optical satellite has a GREEN band.

    ```python
    &gt;&gt;&gt; from eoreader.reader import Reader
    &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
    &gt;&gt;&gt; prod = Reader().open(path)
    &gt;&gt;&gt; prod.get_default_band()
    &lt;OpticalBandNames.GREEN: &#39;GREEN&#39;&gt;
    ```

    Returns:
        str: Default band
    &#34;&#34;&#34;
    return obn.GREEN</code></pre>
</details>
</dd>
<dt id="eoreader.products.optical.optical_product.OpticalProduct.get_default_band_path"><code class="name flex">
<p>def <span class="ident">get_default_band_path</span>(</p><p>self)</p>
</code></dt>
<dd>
<div class="desc"><p>Get default band (<code>GREEN</code> for optical data) path.</p>
<pre><code class="language-python">&gt;&gt;&gt; from eoreader.reader import Reader
&gt;&gt;&gt; path = r&quot;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&quot;
&gt;&gt;&gt; prod = Reader().open(path)
&gt;&gt;&gt; prod.get_default_band_path()
'zip+file://S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip!/S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE/GRANULE/L1C_T30TTK_A027018_20200824T111345/IMG_DATA/T30TTK_20200824T110631_B03.jp2'
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Default band path</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_default_band_path(self) -&gt; str:
    &#34;&#34;&#34;
    Get default band (`GREEN` for optical data) path.

    ```python
    &gt;&gt;&gt; from eoreader.reader import Reader
    &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
    &gt;&gt;&gt; prod = Reader().open(path)
    &gt;&gt;&gt; prod.get_default_band_path()
    &#39;zip+file://S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip!/S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE/GRANULE/L1C_T30TTK_A027018_20200824T111345/IMG_DATA/T30TTK_20200824T110631_B03.jp2&#39;
    ```

    Returns:
        str: Default band path
    &#34;&#34;&#34;
    default_band = self.get_default_band()
    return self.get_band_paths([default_band])[default_band]</code></pre>
</details>
</dd>
<dt id="eoreader.products.optical.optical_product.OpticalProduct.crs"><code class="name flex">
<p>def <span class="ident">crs</span>(</p><p>self)</p>
</code></dt>
<dd>
<div class="desc"><p>Get UTM projection of the tile</p>
<pre><code class="language-python">&gt;&gt;&gt; from eoreader.reader import Reader
&gt;&gt;&gt; path = r&quot;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&quot;
&gt;&gt;&gt; prod = Reader().open(path)
&gt;&gt;&gt; prod.utm_crs()
CRS.from_epsg(32630)
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>rasterio.crs.CRS</code></dt>
<dd>CRS object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def crs(self) -&gt; rasterio.crs.CRS:
    &#34;&#34;&#34;
    Get UTM projection of the tile

    ```python
    &gt;&gt;&gt; from eoreader.reader import Reader
    &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
    &gt;&gt;&gt; prod = Reader().open(path)
    &gt;&gt;&gt; prod.utm_crs()
    CRS.from_epsg(32630)
    ```

    Returns:
        rasterio.crs.CRS: CRS object
    &#34;&#34;&#34;
    band_path = self.get_default_band_path()
    with rasterio.open(band_path) as dst:
        utm = dst.crs

    return utm</code></pre>
</details>
</dd>
<dt id="eoreader.products.optical.optical_product.OpticalProduct.extent"><code class="name flex">
<p>def <span class="ident">extent</span>(</p><p>self)</p>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.product.Product" href="../product.html#eoreader.products.product.Product">Product</a></code>.<code><a title="eoreader.products.product.Product.extent" href="../product.html#eoreader.products.product.Product.extent">extent</a></code>
</p>
<div class="desc inherited"><p>Get UTM extent of the tile …</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extent(self) -&gt; gpd.GeoDataFrame:
    &#34;&#34;&#34;
    Get UTM extent of the tile

    ```python
    &gt;&gt;&gt; from eoreader.reader import Reader
    &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
    &gt;&gt;&gt; prod = Reader().open(path)
    &gt;&gt;&gt; prod.utm_extent()
                                                geometry
    0  POLYGON ((309780.000 4390200.000, 309780.000 4...
    ```

    Returns:
        gpd.GeoDataFrame: Footprint in UTM
    &#34;&#34;&#34;
    # Get extent
    return rasters.get_extent(self.get_default_band_path())</code></pre>
</details>
</dd>
<dt id="eoreader.products.optical.optical_product.OpticalProduct.get_existing_bands"><code class="name flex">
<p>def <span class="ident">get_existing_bands</span>(</p><p>self)</p>
</code></dt>
<dd>
<div class="desc"><p>Return the existing band paths.</p>
<pre><code class="language-python">&gt;&gt;&gt; from eoreader.reader import Reader
&gt;&gt;&gt; path = r&quot;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&quot;
&gt;&gt;&gt; prod = Reader().open(path)
&gt;&gt;&gt; prod.get_existing_bands()
[&lt;OpticalBandNames.CA: 'COASTAL_AEROSOL'&gt;,
&lt;OpticalBandNames.BLUE: 'BLUE'&gt;,
&lt;OpticalBandNames.GREEN: 'GREEN'&gt;,
&lt;OpticalBandNames.RED: 'RED'&gt;,
&lt;OpticalBandNames.VRE_1: 'VEGETATION_RED_EDGE_1'&gt;,
&lt;OpticalBandNames.VRE_2: 'VEGETATION_RED_EDGE_2'&gt;,
&lt;OpticalBandNames.VRE_3: 'VEGETATION_RED_EDGE_3'&gt;,
&lt;OpticalBandNames.NIR: 'NIR'&gt;,
&lt;OpticalBandNames.NNIR: 'NARROW_NIR'&gt;,
&lt;OpticalBandNames.WV: 'WATER_VAPOUR'&gt;,
&lt;OpticalBandNames.CIRRUS: 'CIRRUS'&gt;,
&lt;OpticalBandNames.SWIR_1: 'SWIR_1'&gt;,
&lt;OpticalBandNames.SWIR_2: 'SWIR_2'&gt;]
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>List of existing bands in the products</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_existing_bands(self) -&gt; list:
    &#34;&#34;&#34;
    Return the existing band paths.

    ```python
    &gt;&gt;&gt; from eoreader.reader import Reader
    &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
    &gt;&gt;&gt; prod = Reader().open(path)
    &gt;&gt;&gt; prod.get_existing_bands()
    [&lt;OpticalBandNames.CA: &#39;COASTAL_AEROSOL&#39;&gt;,
    &lt;OpticalBandNames.BLUE: &#39;BLUE&#39;&gt;,
    &lt;OpticalBandNames.GREEN: &#39;GREEN&#39;&gt;,
    &lt;OpticalBandNames.RED: &#39;RED&#39;&gt;,
    &lt;OpticalBandNames.VRE_1: &#39;VEGETATION_RED_EDGE_1&#39;&gt;,
    &lt;OpticalBandNames.VRE_2: &#39;VEGETATION_RED_EDGE_2&#39;&gt;,
    &lt;OpticalBandNames.VRE_3: &#39;VEGETATION_RED_EDGE_3&#39;&gt;,
    &lt;OpticalBandNames.NIR: &#39;NIR&#39;&gt;,
    &lt;OpticalBandNames.NNIR: &#39;NARROW_NIR&#39;&gt;,
    &lt;OpticalBandNames.WV: &#39;WATER_VAPOUR&#39;&gt;,
    &lt;OpticalBandNames.CIRRUS: &#39;CIRRUS&#39;&gt;,
    &lt;OpticalBandNames.SWIR_1: &#39;SWIR_1&#39;&gt;,
    &lt;OpticalBandNames.SWIR_2: &#39;SWIR_2&#39;&gt;]
    ```

    Returns:
        list: List of existing bands in the products
    &#34;&#34;&#34;
    return [name for name, nb in self.band_names.items() if nb]</code></pre>
</details>
</dd>
<dt id="eoreader.products.optical.optical_product.OpticalProduct.get_existing_band_paths"><code class="name flex">
<p>def <span class="ident">get_existing_band_paths</span>(</p><p>self)</p>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.product.Product" href="../product.html#eoreader.products.product.Product">Product</a></code>.<code><a title="eoreader.products.product.Product.get_existing_band_paths" href="../product.html#eoreader.products.product.Product.get_existing_band_paths">get_existing_band_paths</a></code>
</p>
<div class="desc inherited"><p>Return the existing band paths …</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_existing_band_paths(self) -&gt; dict:
    &#34;&#34;&#34;
    Return the existing band paths.

    ```python
    &gt;&gt;&gt; from eoreader.reader import Reader
    &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
    &gt;&gt;&gt; prod = Reader().open(path)
    &gt;&gt;&gt; prod.get_existing_band_paths()
    {
        &lt;OpticalBandNames.CA: &#39;COASTAL_AEROSOL&#39;&gt;: &#39;zip+file://S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip!/S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE/GRANULE/L1C_T30TTK_A027018_20200824T111345/IMG_DATA/T30TTK_20200824T110631_B01.jp2&#39;,
        ...,
        &lt;OpticalBandNames.SWIR_2: &#39;SWIR_2&#39;&gt;: &#39;zip+file://S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip!/S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE/GRANULE/L1C_T30TTK_A027018_20200824T111345/IMG_DATA/T30TTK_20200824T110631_B12.jp2&#39;
    }
    ```

    Returns:
        dict: Dictionary containing the path of each queried band
    &#34;&#34;&#34;
    existing_bands = self.get_existing_bands()
    return self.get_band_paths(band_list=existing_bands)</code></pre>
</details>
</dd>
<dt id="eoreader.products.optical.optical_product.OpticalProduct.load"><code class="name flex">
<p>def <span class="ident">load</span>(</p><p>self, <br>band_and_idx_list, <br>resolution=None, <br>size=None)</p>
</code></dt>
<dd>
<div class="desc"><p>Open the bands and compute the wanted index.</p>
<p>The bands will be purged of nodata and invalid pixels,
the nodata will be set to 0 and the bands will be masked arrays in float.</p>
<p>Bands that come out this function at the same time are collocated and therefore have the same shapes.
This can be broken if you load data separately. Its is best to always load DEM data with some real bands.</p>
<p>If neither resolution nor size is given, bands will be loaded at the product's default resolution.</p>
<pre><code class="language-python">&gt;&gt;&gt; from eoreader.reader import Reader
&gt;&gt;&gt; from eoreader.bands.alias import *
&gt;&gt;&gt; path = r&quot;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&quot;
&gt;&gt;&gt; prod = Reader().open(path)
&gt;&gt;&gt; bands, meta = prod.load([GREEN, NDVI], resolution=20)
&gt;&gt;&gt; bands
{&lt;function NDVI at 0x00000227FBB929D8&gt;: masked_array(
  data=[[[-0.02004455029964447, ..., 0.11663568764925003]]],
  mask=[[[False, ..., False]]],
  fill_value=0.0,
  dtype=float32),
  &lt;OpticalBandNames.GREEN: 'GREEN'&gt;: masked_array(
  data=[[[0.061400000005960464, ..., 0.15799999237060547]]],
  mask=[[[False, ..., False]]],
  fill_value=0.0,
  dtype=float32)}
&gt;&gt;&gt; meta
{
    'driver': 'GTiff',
    'dtype': &lt;class 'numpy.float32'&gt;,
    'nodata': 0,
    'width': 5490,
    'height': 5490,
    'count': 1,
    'crs': CRS.from_epsg(32630),
    'transform': Affine(20.0, 0.0, 199980.0,0.0, -20.0, 4500000.0)
}
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>band_and_idx_list</code></strong> :&ensp;<code>list, index</code></dt>
<dd>Index list</dd>
<dt><strong><code>resolution</code></strong> :&ensp;<code>float</code></dt>
<dd>Resolution of the band, in meters</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>Union[tuple, list]</code></dt>
<dd>Size of the array (width, height). Not used if resolution is provided.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict, dict</code></dt>
<dd>Index and band dict, metadata</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load(self,
         band_and_idx_list: Union[list, BandNames, Callable],
         resolution: float = None,
         size: Union[list, tuple] = None) -&gt; (dict, dict):
    &#34;&#34;&#34;
    Open the bands and compute the wanted index.

    The bands will be purged of nodata and invalid pixels,
    the nodata will be set to 0 and the bands will be masked arrays in float.

    Bands that come out this function at the same time are collocated and therefore have the same shapes.
    This can be broken if you load data separately. Its is best to always load DEM data with some real bands.

    If neither resolution nor size is given, bands will be loaded at the product&#39;s default resolution.

    ```python
    &gt;&gt;&gt; from eoreader.reader import Reader
    &gt;&gt;&gt; from eoreader.bands.alias import *
    &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
    &gt;&gt;&gt; prod = Reader().open(path)
    &gt;&gt;&gt; bands, meta = prod.load([GREEN, NDVI], resolution=20)
    &gt;&gt;&gt; bands
    {&lt;function NDVI at 0x00000227FBB929D8&gt;: masked_array(
      data=[[[-0.02004455029964447, ..., 0.11663568764925003]]],
      mask=[[[False, ..., False]]],
      fill_value=0.0,
      dtype=float32),
      &lt;OpticalBandNames.GREEN: &#39;GREEN&#39;&gt;: masked_array(
      data=[[[0.061400000005960464, ..., 0.15799999237060547]]],
      mask=[[[False, ..., False]]],
      fill_value=0.0,
      dtype=float32)}
    &gt;&gt;&gt; meta
    {
        &#39;driver&#39;: &#39;GTiff&#39;,
        &#39;dtype&#39;: &lt;class &#39;numpy.float32&#39;&gt;,
        &#39;nodata&#39;: 0,
        &#39;width&#39;: 5490,
        &#39;height&#39;: 5490,
        &#39;count&#39;: 1,
        &#39;crs&#39;: CRS.from_epsg(32630),
        &#39;transform&#39;: Affine(20.0, 0.0, 199980.0,0.0, -20.0, 4500000.0)
    }
    ```

    Args:
        band_and_idx_list (list, index): Index list
        resolution (float): Resolution of the band, in meters
        size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.

    Returns:
        dict, dict: Index and band dict, metadata
    &#34;&#34;&#34;
    if not resolution and not size:
        resolution = self.resolution

    if not isinstance(band_and_idx_list, list):
        band_and_idx_list = [band_and_idx_list]

    if len(band_and_idx_list) == 0:
        return {}, {}

    band_list = []
    index_list = []
    dem_list = []
    clouds_list = []

    # Check if everything is valid
    for idx_or_band in band_and_idx_list:
        if is_index(idx_or_band):
            if self._has_index(idx_or_band):
                index_list.append(idx_or_band)
            else:
                raise InvalidIndexError(f&#34;{idx_or_band} cannot be computed from {self.condensed_name}.&#34;)
        elif is_sar_band(idx_or_band):
            raise TypeError(f&#34;You should ask for Optical bands as {self.name} is an optical product.&#34;)
        elif is_optical_band(idx_or_band):
            if self.has_band(idx_or_band):
                band_list.append(idx_or_band)
            else:
                raise InvalidBandError(f&#34;{idx_or_band} cannot be retrieved from {self.condensed_name}.&#34;)
        elif is_dem(idx_or_band):
            dem_list.append(idx_or_band)
        elif is_clouds(idx_or_band):
            clouds_list.append(idx_or_band)

    # Get all bands to be open
    bands_to_load = band_list.copy()
    for idx in index_list:
        bands_to_load += index.NEEDED_BANDS[idx]

    # Load band arrays (only keep unique bands: open them only one time !)
    bands, meta = self._load_bands(list(set(bands_to_load)), resolution=resolution, size=size)

    # Compute index (they conserve the nodata)
    idx_and_bands_dict = {idx: idx(bands) for idx in index_list}

    # Add bands
    idx_and_bands_dict.update({band: bands[band] for band in band_list})

    # Add DEM
    dem_bands, dem_meta = self._load_dem(dem_list, resolution=resolution, size=size)
    idx_and_bands_dict.update(dem_bands)
    if not meta:
        meta = dem_meta

    # Add Clouds
    clouds_bands, clouds_meta = self._load_clouds(clouds_list, resolution=resolution, size=size)
    idx_and_bands_dict.update(clouds_bands)
    if not meta:
        meta = clouds_meta

    # Manage the case of arrays of different size -&gt; collocate arrays if needed
    idx_and_bands_dict = self._collocate_bands(idx_and_bands_dict, meta)

    return idx_and_bands_dict, meta</code></pre>
</details>
</dd>
<dt id="eoreader.products.optical.optical_product.OpticalProduct.get_mean_sun_angles"><code class="name flex">
<p>def <span class="ident">get_mean_sun_angles</span>(</p><p>self)</p>
</code></dt>
<dd>
<div class="desc"><p>Get Mean Sun angles (Azimuth and Zenith angles)</p>
<pre><code class="language-python">&gt;&gt;&gt; from eoreader.reader import Reader
&gt;&gt;&gt; path = r&quot;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&quot;
&gt;&gt;&gt; prod = Reader().open(path)
&gt;&gt;&gt; prod.get_mean_sun_angles()
(149.148155074489, 32.6627897525474)
</code></pre>
<h2 id="returns">Returns</h2>
<p>(float, float): Mean Azimuth and Zenith angle</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def get_mean_sun_angles(self) -&gt; (float, float):
    &#34;&#34;&#34;
    Get Mean Sun angles (Azimuth and Zenith angles)

    ```python
    &gt;&gt;&gt; from eoreader.reader import Reader
    &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
    &gt;&gt;&gt; prod = Reader().open(path)
    &gt;&gt;&gt; prod.get_mean_sun_angles()
    (149.148155074489, 32.6627897525474)
    ```

    Returns:
        (float, float): Mean Azimuth and Zenith angle
    &#34;&#34;&#34;
    raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)</code></pre>
</details>
</dd>
<dt id="eoreader.products.optical.optical_product.OpticalProduct.footprint"><code class="name flex">
<p>def <span class="ident">footprint</span>(</p><p>self)</p>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.product.Product" href="../product.html#eoreader.products.product.Product">Product</a></code>.<code><a title="eoreader.products.product.Product.footprint" href="../product.html#eoreader.products.product.Product.footprint">footprint</a></code>
</p>
<div class="desc inherited"><p>Get UTM footprint of the products (without nodata, <em>in french == emprise utile</em>) …</p></div>
</dd>
<dt id="eoreader.products.optical.optical_product.OpticalProduct.get_datetime"><code class="name flex">
<p>def <span class="ident">get_datetime</span>(</p><p>self, <br>as_datetime=False)</p>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.product.Product" href="../product.html#eoreader.products.product.Product">Product</a></code>.<code><a title="eoreader.products.product.Product.get_datetime" href="../product.html#eoreader.products.product.Product.get_datetime">get_datetime</a></code>
</p>
<div class="desc inherited"><p>Get the product's acquisition datetime, with format <code>YYYYMMDDTHHMMSS</code> &lt;-&gt; <code>%Y%m%dT%H%M%S</code> …</p></div>
</dd>
<dt id="eoreader.products.optical.optical_product.OpticalProduct.get_date"><code class="name flex">
<p>def <span class="ident">get_date</span>(</p><p>self, <br>as_date=False)</p>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.product.Product" href="../product.html#eoreader.products.product.Product">Product</a></code>.<code><a title="eoreader.products.product.Product.get_date" href="../product.html#eoreader.products.product.Product.get_date">get_date</a></code>
</p>
<div class="desc inherited"><p>Get the product's acquisition date …</p></div>
</dd>
<dt id="eoreader.products.optical.optical_product.OpticalProduct.get_band_paths"><code class="name flex">
<p>def <span class="ident">get_band_paths</span>(</p><p>self, <br>band_list, <br>resolution=None)</p>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.product.Product" href="../product.html#eoreader.products.product.Product">Product</a></code>.<code><a title="eoreader.products.product.Product.get_band_paths" href="../product.html#eoreader.products.product.Product.get_band_paths">get_band_paths</a></code>
</p>
<div class="desc inherited"><p>Return the paths of required bands …</p></div>
</dd>
<dt id="eoreader.products.optical.optical_product.OpticalProduct.read_mtd"><code class="name flex">
<p>def <span class="ident">read_mtd</span>(</p><p>self)</p>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.product.Product" href="../product.html#eoreader.products.product.Product">Product</a></code>.<code><a title="eoreader.products.product.Product.read_mtd" href="../product.html#eoreader.products.product.Product.read_mtd">read_mtd</a></code>
</p>
<div class="desc inherited"><p>Read metadata and outputs the metadata XML root and its namespace most of the time,
except from L8-collection 1 data which outputs a pandas DataFrame …</p></div>
</dd>
<dt id="eoreader.products.optical.optical_product.OpticalProduct.has_band"><code class="name flex">
<p>def <span class="ident">has_band</span>(</p><p>self, <br>band)</p>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.product.Product" href="../product.html#eoreader.products.product.Product">Product</a></code>.<code><a title="eoreader.products.product.Product.has_band" href="../product.html#eoreader.products.product.Product.has_band">has_band</a></code>
</p>
<div class="desc inherited"><p>Does this products has the specified band ? …</p></div>
</dd>
<dt id="eoreader.products.optical.optical_product.OpticalProduct.stack"><code class="name flex">
<p>def <span class="ident">stack</span>(</p><p>self, <br>band_and_idx_combination, <br>resolution=None, <br>stack_path=None, <br>save_as_int=False)</p>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.product.Product" href="../product.html#eoreader.products.product.Product">Product</a></code>.<code><a title="eoreader.products.product.Product.stack" href="../product.html#eoreader.products.product.Product.stack">stack</a></code>
</p>
<div class="desc inherited"><p>Stack bands and index of a products …</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="Home" href="/eoreader/">
<img src="https://extracteo.pages.sertit.unistra.fr/eoreader/eoreader.png"
alt="logo"
style="width:40%;"/>
</a>
</header>
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="eoreader.products.optical" href="index.html">eoreader.products.optical</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code></h4>
<ul>
<li>
<h4><code>Functions</code></h4>
</li>
<li>
<ul class="">
<li><code><a title="eoreader.products.optical.optical_product.OpticalProduct.get_default_band" href="#eoreader.products.optical.optical_product.OpticalProduct.get_default_band">get_default_band</a></code></li>
<li><code><a title="eoreader.products.optical.optical_product.OpticalProduct.get_default_band_path" href="#eoreader.products.optical.optical_product.OpticalProduct.get_default_band_path">get_default_band_path</a></code></li>
<li><code><a title="eoreader.products.optical.optical_product.OpticalProduct.crs" href="#eoreader.products.optical.optical_product.OpticalProduct.crs">crs</a></code></li>
<li><code><a title="eoreader.products.optical.optical_product.OpticalProduct.extent" href="#eoreader.products.optical.optical_product.OpticalProduct.extent">extent</a></code></li>
<li><code><a title="eoreader.products.optical.optical_product.OpticalProduct.get_existing_bands" href="#eoreader.products.optical.optical_product.OpticalProduct.get_existing_bands">get_existing_bands</a></code></li>
<li><code><a title="eoreader.products.optical.optical_product.OpticalProduct.get_existing_band_paths" href="#eoreader.products.optical.optical_product.OpticalProduct.get_existing_band_paths">get_existing_band_paths</a></code></li>
<li><code><a title="eoreader.products.optical.optical_product.OpticalProduct.load" href="#eoreader.products.optical.optical_product.OpticalProduct.load">load</a></code></li>
<li><code><a title="eoreader.products.optical.optical_product.OpticalProduct.get_mean_sun_angles" href="#eoreader.products.optical.optical_product.OpticalProduct.get_mean_sun_angles">get_mean_sun_angles</a></code></li>
<li><code><a title="eoreader.products.optical.optical_product.OpticalProduct.footprint" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.footprint">footprint</a></code></li>
<li><code><a title="eoreader.products.optical.optical_product.OpticalProduct.get_datetime" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.get_datetime">get_datetime</a></code></li>
<li><code><a title="eoreader.products.optical.optical_product.OpticalProduct.get_date" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.get_date">get_date</a></code></li>
<li><code><a title="eoreader.products.optical.optical_product.OpticalProduct.get_band_paths" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.get_band_paths">get_band_paths</a></code></li>
<li><code><a title="eoreader.products.optical.optical_product.OpticalProduct.read_mtd" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.read_mtd">read_mtd</a></code></li>
<li><code><a title="eoreader.products.optical.optical_product.OpticalProduct.has_band" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.has_band">has_band</a></code></li>
<li><code><a title="eoreader.products.optical.optical_product.OpticalProduct.stack" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.stack">stack</a></code></li>
</ul>
</li>
<li>
<h4><code>Variables</code></h4>
</li>
<li>
<ul class="two-column">
<li><code><a title="eoreader.products.optical.optical_product.OpticalProduct.output" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.output">output</a></code></li>
<li><code><a title="eoreader.products.optical.optical_product.OpticalProduct.name" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.name">name</a></code></li>
<li><code><a title="eoreader.products.optical.optical_product.OpticalProduct.split_name" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.split_name">split_name</a></code></li>
<li><code><a title="eoreader.products.optical.optical_product.OpticalProduct.archive_path" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.archive_path">archive_path</a></code></li>
<li><code><a title="eoreader.products.optical.optical_product.OpticalProduct.path" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.path">path</a></code></li>
<li><code><a title="eoreader.products.optical.optical_product.OpticalProduct.is_archived" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.is_archived">is_archived</a></code></li>
<li><code><a title="eoreader.products.optical.optical_product.OpticalProduct.needs_extraction" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.needs_extraction">needs_extraction</a></code></li>
<li><code><a title="eoreader.products.optical.optical_product.OpticalProduct.date" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.date">date</a></code></li>
<li><code><a title="eoreader.products.optical.optical_product.OpticalProduct.datetime" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.datetime">datetime</a></code></li>
<li><code><a title="eoreader.products.optical.optical_product.OpticalProduct.tile_name" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.tile_name">tile_name</a></code></li>
<li><code><a title="eoreader.products.optical.optical_product.OpticalProduct.sensor_type" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.sensor_type">sensor_type</a></code></li>
<li><code><a title="eoreader.products.optical.optical_product.OpticalProduct.product_type" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.product_type">product_type</a></code></li>
<li><code><a title="eoreader.products.optical.optical_product.OpticalProduct.band_names" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.band_names">band_names</a></code></li>
<li><code><a title="eoreader.products.optical.optical_product.OpticalProduct.is_reference" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.is_reference">is_reference</a></code></li>
<li><code><a title="eoreader.products.optical.optical_product.OpticalProduct.corresponding_ref" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.corresponding_ref">corresponding_ref</a></code></li>
<li><code><a title="eoreader.products.optical.optical_product.OpticalProduct.nodata" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.nodata">nodata</a></code></li>
<li><code><a title="eoreader.products.optical.optical_product.OpticalProduct.platform" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.platform">platform</a></code></li>
<li><code><a title="eoreader.products.optical.optical_product.OpticalProduct.resolution" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.resolution">resolution</a></code></li>
<li><code><a title="eoreader.products.optical.optical_product.OpticalProduct.condensed_name" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.condensed_name">condensed_name</a></code></li>
<li><code><a title="eoreader.products.optical.optical_product.OpticalProduct.sat_id" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.sat_id">sat_id</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>
